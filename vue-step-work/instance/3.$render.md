在 `$mount` 中通过渲染 `watcher` 调用回调函数 `updateComponent` 实现一个真实的渲染。
`updateComponent` 是一个函数， 内部调用了 `vm` 上的两个私有方法 `$_update` 和 `$_render`。 

`$render` 方法定义在 `core/instance/render.js` 的 `renderMixin` 中

```javascript
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options

  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots(
      _parentVnode.data.scopedSlots,
      vm.$slots,
      vm.$scopedSlots
    )
  }

  // set parent vnode. this allows render functions to have access
  // to the data on the placeholder node.
  vm.$vnode = _parentVnode
  // render self
  let vnode
  try {
    // There's no need to maintain a stack because all render fns are called
    // separately from one another. Nested component's render fns are called
    // when parent component is patched.
    currentRenderingInstance = vm
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    handleError(e, vm, `render`)
    // return error render result,
    // or previous vnode to prevent render error causing blank component
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
      try {
        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
      } catch (e) {
        handleError(e, vm, `renderError`)
        vnode = vm._vnode
      }
    } else {
      vnode = vm._vnode
    }
  } finally {
    currentRenderingInstance = null
  }
  // if the returned array contains only a single node, allow it
  if (Array.isArray(vnode) && vnode.length === 1) {
    vnode = vnode[0]
  }
  // return empty vnode in case the render function errored out
  if (!(vnode instanceof VNode)) {
    if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
      warn(
        'Multiple root nodes returned from render function. Render function ' +
        'should return a single root node.',
        vm
      )
    }
    vnode = createEmptyVNode()
  }
  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

可以看到 `_render` 函数返回的是一个 `VNode`, 这样一个vnode是由 `$options` 的 `render` 函数 `call` 了一个 `vm._renderProxy`, 并传入参数 `$createElement` 

`$createElement` 是在 `initRender` 函数中(在 `_init` 方法中调用)定义, 函数返回调用 `createElement` 生成的vnode
`vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)`

`_renderProxy` 同样也是在 `init` 函数中, 生产环境就是 `vm` 本身也就是 `this`, 开发环境则调用 `initProxy` 函数, `initProxy` 函数在 `proxy.js` 中, 首先判断是否支持 `Proxy` (es6新特性, 代理), 如果支持, 在代理一个 `handlers`, 这里返回一个 `hasHandler`, 而 `hasHandler` 中 会对 属性进行一个判断(不是全局属性，私有属性等) 抛出一个常见的错误 `warnNonPresent` 
```javascript
initProxy = function initProxy (vm) {
  if (hasProxy) {
    // determine which proxy handler to use
    const options = vm.$options
    const handlers = options.render && options.render._withStripped
      ? getHandler
      : hasHandler
    vm._renderProxy = new Proxy(vm, handlers)
  } else {
    vm._renderProxy = vm
  }
}
```

不防改写一下代码
```javascript
new Vue({
  el: '#app',
  render(createElement) {
    createElement('div', {
      attr: 'newApp'
    }, this.message)
  },
  data() {
    return {
      message: 'Eloim Essaim'
    }
  }
})
```
画面可以看到，同样渲染出来，但是没有了插值变化的一个过程， 同时也可以看到，节点现在的id是 newApp, 所以这也回答之前的问题，为什么不能在body上挂载, 会将原标签替换。
